# 计算机组成原理阅读

## 第二章 计算机指令

### 2.1 概述

* 主要是介绍指令集的概念，个人理解为直接操作计算机硬件的机器语言。
* 指令集的执行对象主要是寄存器和存储器，而不是传统硬件意义上的内存以及硬盘。寄存器实际上是位于CPU内部的。

### 2.2 计算机硬件的操作

* 首先从一个加法指令开始：

  ```assembly
  add a, b, c
  add a, a, d
  add a, a, e
  ```

  该MIPS指令实现了`a=b+c+d+e;`的功能。

* 相应的，有`sub d, a, b`，实现减法功能。

### 2.3 计算机硬件的操作数

* **设计原则1**：简单源自规整

* 2.2中的语法，无法在硬件中直接实现，算数的运算指令必须取自于寄存器。在MIPS系统中，寄存器的位数为32位。（现在使用的机器都是64位的机器，寻址空间不止32位的4G）。
* 增加限制条件，MIPS运算的三个操作数必须从寄存器中选取，寄存器的个数也是32个。并且使用`$`后跟两个字符代表寄存器的编号，`$s0...`对应于变量，`$t0...`对应临时寄存器。
* **设计原则2**：越少越快，此处指的应该是寄存器的个数。

#### 2.3.1 存储器操作数

* 想要实现`g=h+A[8];`，数组变量`A[8]`无法放入到寄存器内，在存储器中，所以需要一个从存储器到寄存器的取指令操作`lw`。

  ```assembly
  lw $t0, 8($s3)
  ```

  寄存器`$s3`中存放的是`A[8]`的首地址，结果写入`$t0`临时寄存器中。

* **字节和字**：1个字节(byte)永远代表8 bits，一个字(word)指带寄存器中存放的所有二进制的长度，对于32位机器，一个字指4个字节，对于16位机器一个字指2个字节。
  在本书中MIPS32位体系结构中，一个字占4个字节。

* 考虑了偏移地址之后，上述的指令应该更改为：

  ```assembly
  lw $t0, 32($s3)
  ```

  因为大多数系统是按照字节来编址，如果认为`A[8]`每个元素都是`int`类型，占4个字节或者说1个字，则应该偏移32个地址。

* 相应地，有存储字指令`sw`

  ```assembly
  sw $t0, 48($s3)
  ```

  写寄存器`$t0`到相应的存储器中。

#### 2.3.2 常数或者立即数操作

* 引入指令`addi`

  ```assembly
  addi $s3, $s3, 100
  ```

* 对于Intel IA-32，拥有 $2^{30}$个存储器。

* **设计原则3**：加速执行常用操作。立即数的加减应该经常出现，需要添加到指令集中。

### 2.4 计算机中的指令的表示

* 目的是为了使用二进制表示指令集，对于本书的例子而言，指令集的二进制长度为32位。

  <img src="D:%5CNotesCloud%5CComputer%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%98%85%E8%AF%BB.assets%5Cimage-20200923190955159.png" alt="image-20200923190955159" style="zoom:40%;" />

* 如表所示，各个寄存器对应的编号

* **设计原则4**：优秀的设计需要适当的折中。
  所有的指令长度都是相同的32位，但是不同的指令采用不同的指令格式。主要有两种指令格式，R（寄存器）型和I型（立即数）。下图展示了两种类型的指令位数
  <img src="D:%5CNotesCloud%5CComputer%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%98%85%E8%AF%BB.assets%5Cimage-20200923200837678.png" alt="image-20200923200837678" style="zoom:80%;" />

  ![image-20200923200912233](D:%5CNotesCloud%5CComputer%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%98%85%E8%AF%BB.assets%5Cimage-20200923200912233.png)

### 2.5 逻辑运算

* 增加`and`, `nor`, `or`三类逻辑指令，没有`not`是因为可以利用`nor`替代`not`。

### 2.6 分支指令

* 引入了新的指令`beq`，`bnq`，意为：branch if (not) equal，用法：

  ```assembly
  beq $t0, $s5, Exit  # go to Exit if
  bnq $t0, $s5, Exit  # go to Exit if not
  ```

* 基本块的概念：目前，以`Loop:`开头，`Exit:`结尾的一段指令序列，称为一个基本块。分支指令实现了在基本块中的跳转。

* 引入`slt`, `slti`:

  ```assembly
  slt $t0, $s3, $s4	# $t0 == 1 if $s3 < $s4
  slt $t0, $s3, 10	# $t0 == 1 if $s3 < 10
  ```

* 没有引入小于时的分支指令，为了性能。可以与寄存器`$zero`比，实现各种分支。

* 引入跳转地址指令`j`：

  ```assembly
  j L
  ```

  直接跳转到目标地址。

### 2.7 计算机硬件的过程支持

* 主要描述了硬件如何执行指令的过程，此处引入了`$ra`寄存器，用于存储返回地址。同时引入了`jal`和`jr`指令：

  ```assembly
  jal ProcedureAddress  # 跳转到某个地址并将当前指令地址存到$ra中
  jr $ra	# 直接跳转到$ra中指定的地址
  ```

#### 2.7.1 使用更多寄存器

* 寄存器`$t0-$t9`是临时寄存器，使用过程中，不用保存数据，而`$s0-$s7`8个寄存器，使用过程中必须保存，结合栈寄存器`$sp`可以实现：

  ```assembly
  addi $sp, $sp, -4	#增加一个字的地址，用于存放$s0的值
  sw $s0, 0($sp)	#将$s0中的内容写入$sp指向的存储器空间一个字内
  sub $s0, $t0, $t1	#使用$s0
  add $v0, $s0, $zero		#$v0为返回寄存器，$zero为0寄存器
  lw $s0, 0($sp)	#将$sp中存储的内容重新写回$s0中
  addi $sp, $sp, 4	#删除一个字的地址空间，表示pop
  ```

#### 2.7.2 嵌套过程

* 程序的嵌套过程，一个递归的例子：

  ```c
  int fact(int n)
  {
  	if (n<1) return (1);
  	else return (n* fact(n-1));
  }
  ```

  ```assembly
  fact:
  	addi $sp, $sp, -8  #adjusst stack for 2 items
  	sw $ra, 4($sp) 	#save the return address
  	sw $a0, 0($sp)	#save the argument n
  	slti $t0, $a0, 1 	#test for n<1
  	beq $t0, $zero, L1	#if n>=1, go to L1
  	addi $v0, $zero, 1 		#return 1
  	addi $sp, $sp, 8	#pop 2 items off stack
  	jr $ra
  L1:
  	addi $a0, $a0, -1	#n>=1: argument gets n-1
  	jal fact	#call fact with n-1
  	lw $a0, 0($sp)	# return from jal:restore argument n
  	lw $fa, 4($sp) 	 # restore the return address
  	addi $sp, $sp, 8 	#adjust stack pointer to pop 2 items
  	mul $v0, $a0, $v0 	#return n* fact (n-1)
  	jr $ra 		#return to the caller
  ```

* 没有完全理解过程，总之可以实现指令的跳转，结合栈实现递归。

* 过程调用中存在保留与未保留的寄存器，`$t`, `$a`, `$v`以及栈指针以下的栈空间（即地址高的空间）都可以被使用，称作未保留，而其他寄存器包括已经入栈的`$sp`以上的栈空间则被保留。

#### 2.7.3 在栈中为新数据分配空间

* 引入`$fp`帧指针，并没有理解。总之，使用帧指针可以保存之前`$sp`的位置，某个代码段结束后，即可重新定位`$sp`到先前的位置。

#### 2.7.4 在堆中为数据分配新空间

* 栈底是高地址，栈顶是低地址，入栈的时候需要将`$sp`地址做减
* C语言的堆分配空间为malloc()函数，free()释放该空间
* 内存中的分配，地址从低到高依次为：保留段，正文数据(代码段)，静态数据，动态数据（栈）。

### 2.8 人机交互

* ASCII码
* 引入了两个读写字节的指令，`lb`, `sb`，用法跟`lw`, `sw`类似，取某个地址的一个字节放入寄存器的右边8位。
* 叶过程就是独立的不调用其他过程的一个过程，而且不存在自身的递归。叶过程本可以使用临时寄存器`$t`，但是由于其他非叶过程可能需要调用叶过程，所以还是使用栈加保存临时寄存器来实现。
* 引入了读半字的指令，`lh`, `sh`，读取16位的内容。

### 2.9 32位立即数的MIPS编址和寻址

#### 2.9.1 32位立即数

* 引入`liu`指令，取立即数的高位，事实上是取立即数的高16位赋值给寄存器的高位。
* 若要读一个32位常熟，首先应该取高16位，使用`liu $s0, XX`，然后使用`ori`将低位的数加至`$s0`中。值得注意的是，`addi`, `ori`等指令支持的立即数都是16位。

#### 2.9.2 分支和跳转中的寻址

* 对于跳转指令`j`，其跳转操作码为6位，剩下的26位全部代表地址，这里的地址代表字地址，例如`j 10000`，实际上跳转至了字节地址为40000的代码段。注意区分字节地址和字地址。
  ![image-20200925150239019](D:%5CNotesCloud%5CComputer%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%98%85%E8%AF%BB.assets%5Cimage-20200925150239019.png)

* 条件分支的分支地址只有16位，此时的寻址方式为PC相对寻址（program counter)，PC寄存器是由编译器指定的一个寄存器，MIPS架构里面并未保留。
  ![image-20200925150532223](D:%5CNotesCloud%5CComputer%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%98%85%E8%AF%BB.assets%5Cimage-20200925150532223.png)
  PC保留的是下一条指令的地址，使用`bne`条件分支的时候理论上可以寻址$PC+-2^{17}$个字节地址。
  对于超过16位字寻址范围的地址，可以结合`j`实现远距离的分支转移：
  <img src="D:%5CNotesCloud%5CComputer%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E9%98%85%E8%AF%BB.assets%5Cimage-20200925151553826.png" alt="image-20200925151553826" style="zoom:50%;" />

#### 2.9.3 MIPS寻址模式总结

* 寄存器寻址
* 基址或者偏移寻址
* 立即数寻址
* PC相对寻址
* 伪直接寻址：把形式地址中的26位字地址左移两位变成字节地址，再与PC高4位相拼接得到伪直接地址。

#### 2.9.4 机器语言解码

* 根据机器二进制语言解码出MIPS指令，较为程序化。

### 2.10 程序的执行过程

* 常见的C代码执行过程，通过编译，汇编，链接（库），得到可执行文件，通过加载器加载到存储器中运行。

#### 2.10.2 汇编器

* MIPS指令中没有`move`指令，例如代码：

  ```assembly
  move $t0, $t1 	# 将$t1值加至$t0
  add $t0, $zero, $t1 	
  ```

  二者是等价的，汇编器会把上述第一行汇编位第二行。
  总的来说，汇编器将更高级的伪指令转换为MIPS基础指令，丰富指令集。

* 汇编完后产生一个.obj file，目标文件，内部包含6个部分：

  1. 目标文件头，正文段和数据段的大小，位置信息等等
  2. 正文段，机器语言代码
  3. 数据段，包括静态以及动态数据段
  4. 重定位信息
  5. 符号表，未定义的剩余标记，例如外部引用
  6. 调试信息

#### 2.10.3 链接器

* 把目标文件拼接到一起，生成可执行文件或者库文件。
* 链接的时候根据符号表来更新各个obj file中的地址。

#### 2.10.4 加载器

* 加载磁盘中的可执行文件，放到内存中，并分配相应的地址空间，初始化栈等等。





## 总结

至此，了解了计算机底层的运行原理，主要是了解了冯诺依曼体系结构中的运算器，寄存器，存储器，I\O结构。程序运行过程中的硬件原理，以及代码段数据段的含义。

