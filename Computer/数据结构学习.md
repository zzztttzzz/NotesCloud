# 数据结构

## 绪论（上）

* 算法得保证有穷性，程序不一定是算法。例如，Haistone序列

  ```c++
  int Hailstone(int n)
  {
  	int length = 1;
  	while(1<n) { (n%2) ? n = 3*n +1: n = n/2; lenth++;}
      return length;
  }
  ```

  还未证明是一个有穷的序列。

* > Algorithms + Data Structure = Programs
  >
  > (Algorithms + Data Structure) * Efficiency  = Computation

* 考虑算法的性能，主要关注时间消耗，内存占用可能不是很关注。
  往往关注同等输入规模下的最坏情况。
  解决同一个问题，性能评价受多种因素制约，例如编译器，编程语言，操作系统，体系结构不同。需要抽象出一个图灵机模型来评价。
* 图灵机模型和RAM模型，都是无限存储空间（无限长的纸带，无限的内存空间），算法运行时间转化为算法运行的次数。



* 大$O$记号，大$\Omega$，大$\Theta$，可以分别代表最坏情况，最好情况以及平均情况下的时间复杂度。
* 多项式时间内可以解决的问题可以认为都是比较高效的。而具有指数复杂度的问题称为难解的。例如：
  2-Subset问题，n个正整数的和为2m，找到一个子集使其和为m。是一个np-complete.



## 绪论（下）

* C++的基本指令，等效于常数条RAM模型的基本指令，渐进意义下，二者大体相当。

* 级数的知识：

  幂次级数的和，由于$\sum_{\mathrm{k}=0}^{n} k^{d} \approx \int_{0}^{n} x^{d+1} d x=\left.\frac{1}{d+1} x^{d+1}\right|_{0} ^{n}=\frac{1}{d+1} n^{d+1}=O\left(n^{d+1}\right)$，

  $T(n) = 1+2+...+n = O(n^2)$

  $T_2(n) = 1^2+2^2+...+n^2 = O(n^3)$

  阶数比指数高1.

* 调和级数的常用的两个界：
  $\begin{array}{l}
  h(n)=1+1 / 2+1 / 3+\cdots+1 / n=\Theta(\log n) \\
  \log 1+ \log2+ \log3+\cdots+\log n=\log (n !)=\Theta(n \log n)
  \end{array}$

* **时间复杂度的分析**



* 空间复杂度泛指所需额外空间的数量。



* 递归函数的时间复杂度分析主要有两种，递推跟踪和利用递推式求解。介绍了分治和减治。



* 动态规划，Fibonacci为实例。
  展开来说，如果采用递归的算法：

  ```c++
  __int64 fib ( int n ) { //计算Fibonacci数列的第n项（二分递归版）：O(2^n)
     return ( 2 > n ) ?
            ( __int64 ) n //若到达递归基，直接取值
            : fib ( n - 1 ) + fib ( n - 2 ); //否则，递归计算前两项，其和即为正解
  }
  ```

  时间复杂度O(2^n)，准确一点大约是$\Theta(1.618^n)$，而且空间复杂度约为O(n)。
  一般采用迭代的算法，减小栈的压力：

  ```c++
  __int64 fibI ( int n ) { //计算Fibonacci数列的第n项（迭代版）：O(n)
     __int64 f = 1, g = 0; //初始化：fib(-1)、fib(0)
     while ( 0 < n-- ) { g += f; f = g - f; } //依据原始定义，通过n次加法和减法计算fib(n)
     return g; //返回
  }
  ```



* 最长公共子序列问题（LCS）：
  如果采用简单的递归，从末尾开始去除相同char，分治的方法，时间复杂度为O(2^n)。
  换用动态规划方法，时间复杂度为$\Theta(mn)$，m, n分别为两个序列的长度。



## 向量（上）

> 接口与实现

* 数据结构跟类型等同起来，抽象数据类型的概念。说白了，写个class或者struct可以定义为一种数据类型。
* `array`是基本数据结构，想要手写一个`vector`，需要提供各种各样的接口。
* 基本的inset, find较好理解。关于search, 定义返回不超过目标元素的最大索引，排序默认从小到大。

* uniquify, 只保留不同的元素。

* `typedef`关键字，功能上或许跟宏类似，但是原理完全不同。

> 可扩充向量

* 在静态空间管理中，采用固定容量策略，`_capacity`代表了向量的总容量，`_size`代表当前的实际规模，需要考虑空间上溢下溢的效率问题。
* 改变使用动态空间管理，当上溢的时候new一个新的空间，复制后再进行插入操作。
* 递增式扩容：每次new时都增加`I`个元素的空间，则在元素个数足够多的时候，时间复杂度主要来自于复制操作，输入规模为`n`，时间复杂度则为$O(n^2)$。空间装填因子效率更高。
* 加倍式扩容：每次new均采用加倍式的扩容方式，即对于一个初始为0的vector来说，第1,2,4,8...次插入需要扩容，总体的时间复杂度为$O(n)$。装填因子效率大于50%。
* 分摊复杂度，连续地输入多次操作，看总运行时间然后分摊给各次操作。而平均复杂度只是对某种概率输入估计出来的加权时间复杂度。

> 无序向量

* 插入：后续的元素从最后一个开始移位
* 删除：将待删除区间从前向后覆盖，有必要缩容
* 删除单个元素，即`remove(r,r+1)`。
* 查找：find，$O(n)$
* 唯一化：按照从前往后的顺序，假如find返回1，然后remove当前元素，$O(n^2 )$

> 有序向量

* 如何甄别向量是否有序，`disordered()`函数，返回0代表有序，实际上就是检查逆序对的个数
* 唯一化，未经优化的时候，与无序向量中的唯一化类似，虽然不用find，但是逐元素的remove操作仍然会带来$O(n^2)$的复杂度。
* `uniquify()`，优化之后达到了$O(n)$的复杂度，只需要一次遍历就可以完成，多余的元素不用显式地删除，只需要指定好新的size即可。

* 二分查找，接口为：

  ```c++
  Rank Vector<T>::search(T const& e, Rank lo, Rank hi) const {}
  ```

  为了方便查找，返回的Rank为不大于e的最后一个元素的Rank，这样可以方便调用insert，即：

  ```c++
  V.insert(1+V.search(e),e);
  ```

  e若比V中所有元素都小，`search`返回-1，都大则返回`hi-1`

* 有序向量二分查找的查找长度，向左跟向右做if的次数不一样，可以计算出平均的时间复杂度，优化前为$1.5log(n)$

* 有序向量的Fibonacci查找：中间点的选取不同，可以保证复杂度降为$O(1.44log(n))$
* 有序向量的二分查找改进：思路是使左右分支的代价变平衡，版本C
* 插值查找，时间复杂度为$O(log(log(n)))$，只针对具有均匀分布的数组可以提高效率。



> 起泡排序

* 基础的起泡排序是遍历找相邻两个逆序对，如果为逆序则交换。
* 可以记录下来某趟扫描是否存在逆序对，如果不存在，则后续不用再重新扫描。可以在某些情况下提高效率。
* 可以记录最后一个逆序对的位置，将高位终止于此位置，可以进一步优化起泡排序。

> 归并排序

* $T(n)= 2*T(n/2)+O(n)$,在上述递推式下的总的复杂度为$O(nlogn)$。



##  列表

> 接口 无序列表

* 采用动态存储结构，元素称为节点。相邻的节点彼此互相称为前驱和后继，存在首末节点没前驱或者后继。
* 向量可以根据秩直接找到元素的地址，列表则通过前驱后继寻找。定义首末两个哨兵节点，其rank分别为-1,n，对于外部来讲是不可见的。
* 如果对列表进行循秩访问，时间复杂度为$O(n)$，不可接受。
* 查找：`find(T const& e, int n, ListNodePosi(T) p)`，在p的n个前驱中寻找元素e。
* 插入分为前向插入和后向插入，只用改变三个节点的前驱后继即可。

> 有序列表

* 唯一化，时间复杂度为$O(n)$，比无序列表速度快。
* search，最好$O(1)$，最坏$O(n)$，相比于无序列表没什么优势。

> 插入排序

* 利用列表插入时间复杂度为$O(1)$的特性，可以逐个元素选择放入到不大于该元素之前的位置。
* 总体的时间复杂度依然为$O(n^2)$，原因在于，在有序的列表中查找的时候，无法使用二分查找。

> 选择排序

* 与插入排序相反，每次先搜索一个最大的元素，然后放入到最终的列表中去



## 栈与队列

> 栈的接口

* push, pop, top, empty
* 可以分别通过list以及vector来实现一个栈。

> 栈的应用场景

* 进制转换(逆序输出)：计算进制转化要实现结果的逆序输出，自然可以用栈实现。