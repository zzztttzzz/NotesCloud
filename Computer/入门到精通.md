# 入门到精通

## 基础

* `&`和`&&`的区别，按位与和逻辑与。后者只要有0输出false，前者二进制按位与，后者输出逻辑值。

* `^`是按位异或，`~`按位取反

* 隐式转换往`double`靠拢。强制类型转换不改变变量定义本身类型：

  ```c++
  double x;
  cout << (int)x << endl;
  ```

  `x`仍然为`double`类型。

* 默认参数，直接在函数定义处变量名给等号。默认参数应该出现在参数列表的右侧。例如：

  ```c++
  int GetMax(int x, int y=10, int z) //非法
  ```

* 可变参数，使用`...`实现，需要`#include <stdarg.h>`，该头里定义了`va_list`, `va_start`, `va_end`, `va_copy`四个类，使用样例：

  ```c++
  void OutputInfo(int num,...)
  {
  	va_list arguments;
  	va_start(arguments, num);
  	while(num--)
  	{
  		char* pchData = va_arg(arguments, char*);
  		int iData = va_arg(arguments, int);
  		cout << pchData << endl;
  		cout << iData << endl;
  	}
  	va_end(arguments);
  }
  ```

* 函数重载，编译器根据参数的类型以及个数来区分重载，而不是根据返回值的类型来区分。

* 内联函数，不用栈。`inline int Add2Number(int x, int y);`。频繁使用小函数用内联可以降低调用函数的开销。

* 大括号规定了变量的作用域，内部定义的变量的生命周期存在于内部，可以看作是存放在栈上。

  ```c++
  int main()
  {
  	int a = 3;
  	{
  		cout << a << endl;
  		int b = 4;
  		cout << b << endl;
  	}
  	cout << b << endl;  // 此处无法编译通过
  }
  ```

* `auto`变量是c++中默认的变量类型，相对应的有`static`, `register`, `extern`变量。



## 数组指针引用

* 二维数组，表象上，c++是用行索引，例如定义一个3行4列的数组：

  ```c++
  int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
  int b[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
  ```

* 字符数组，末尾跟`\0`，可以让输出没有乱码，但是实测不手动加`\0`，数组长度足够的话，编译器会帮忙自动补零。
  `strcat(str1,str2)`可以将`str2`拼接至`str1`末尾。
  `strcpy(str1,str2)`将`str2`复制给`str1`，执行后`str1`原来的值消失。
  `strcmp(str1,str2)`比较两个字符数组，相同返回0

  `strlen(str)`返回字符数组的长度，不包含`\0`；

* 指针加法：`int* p`, 运算`p = p+1`时，不代表地址的实际数值加1，而是加4.
  `p = p+1`等效于`p = (int*)((int)p+sizeof(*p))`.

* 常量指针，指针常量：根据汉语的语法准则，后半部分为名词，前半部分为修饰，扩展读法应该为常量的指针，指针是常量。

  ```c++
  int* const p = &a;  // p是(int*),为指针常量
  const int* p = &a; // p指向一个const int，不可通过p更改a的值，为常量指针
  ```

* 指针数组，数组指针：指针数组是个数组，数组指针是个指针。前者数组里存放指针，后者是一个指向数组的指针。

  ```c++
  int a[3][4]; // 一个二维数组
  int(*b)[4] = a; // 数组指针，指向a数组的一个指针；
  int* c[4]; // 指针数组，一个存放4个指针的数组
  //索引一个数组，可以通过数组指针索引
  cout << a[1][2] << endl; //等价于
  cout << *(*(b+1)+2) << endl;
  ```

* 函数指针：定义一个指针指向函数，可以用指针调用该函数。

  ```c++
  int sum_two(int a,int b){return a+b;}
  int (*a)(int,int) = sum_two; // or int(*a)(int,int) = &sum_two;
  ```

  返回指针的函数：

  ```c++
  int* pointerGet(int a){return &a;}
  ```

* 强制转换查看big endian的内存方式：

  ```c++
  int a = 0x919;
  cout << (int)(*(char*)((int)(&a) + 0)) << endl; //19
  cout << (int)(*(char*)((int)(&a) + 1)) << endl; //9
  cout << (int)(*(char*)((int)(&a) + 2)) << endl; //0
  cout << (int)(*(char*)((int)(&a) + 3)) << endl; //0
  //使用(char*)只寻址当前的一个字节
  ```

* 引用和右值引用：c++中所有的值只有三种，左值、右值、将亡值。右值引用后续可以实现完美转发。根据cppreference官网的说法，左值即lvalue，右值即rvalue，一些说法认为lvalue代表located value, rvalue代表read value，应该是理解上的偏差。

  ```c++
  int& var = 0;// 非法
  const int& var = 0; //合法
  int&& var = 0; //合法
  // 
  ```

  右值引用可以传递参数，例如：

  ```c++
  void offset(float &&f){globalVar+=f;}
  void offset(float &f){globalVar+=f;} //实现 传递引用参数的函数offset的重载
  ```

* 带参数的主函数入口：

  ```c++
  int main(int argc, char* argv[]){}
  ```

  `argc`是参数个数，可以使用`*argv`来取出输入的参数，均以字符形式输入，看具体问题。


## 类和对象

* 类的成员变量成员函数，对象理解为类的实例

* 构造函数，析构函数，与类名相同的函数。构造函数也可以实现多态。

  ```c++
  class CPerson
  {
  	public:
  	CPerson();
  	int m_iIndex;
  	int getIndex();
      ~CPerson();
  }
  ```

* 复制构造函数，可以实现深拷贝，避免浅拷贝的指针指向同一块内存，进一步导致析构报错。

  ```c++
  CPerson::CPerson(CPerson & copyPerson){
  m_iIndex = copyPerson.m_iIndex;
  m_shAge = copyePerson.m_shAge;
  m_dSalary = copyePerson.m_dSalary;
  }
  ```

* 类成员函数：`class`的数据成员默认都是`private`的，只有类作用域内能被访问。`public`以及`protected`的方式。默认的成员函数都是`inline`成员函数，且`inline`只在定义的时候管用，定义时不加`inline`依然不是`inline`，即使声明了是`inline`。

* 静态类成员：可以直接通过类名访问`static`对象，当然得首先是`public`的。

  * 无论该类有多少个对象，大家都共享一个静态成员变量。
  * 普通成员变量无法当作成员函数的默认参数，但是静态成员可以。

* 静态类函数：只能访问静态类内变量，不能访问普通类内变量。

* `this`，对于类的对象，每个对象都有各自的非静态数据成员，但是共享着成员函数。`this`实际上是隐藏的一个指针，指向该类。

* `friend`友元，核心是为了让别的类的函数访问该类的私有成员，在类的定义中声明为友元就可以了。

